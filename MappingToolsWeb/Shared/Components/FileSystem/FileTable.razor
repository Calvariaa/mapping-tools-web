@using TG.Blazor.IndexedDB
@using MappingToolsWeb.IndexedDB
@using MappingToolsWeb.IndexedDB.Records
@using MappingToolsWeb.IndexedDB.Records.Implementations

@inject IndexedDBManager IndexedDbMgr
@inject IContentTagManager IContentTagManager
@inject IIndexedDbCache<ContentTag, IOrderedFileRecords, IFileRecord> IndexedDbCache

<div hidden="@(!ShowContent)">
    @if(Files.Count > 0) {
    <h3>@Name</h3>
    
    <ul class="file-table-list">
        @foreach(var file in Files) {
            <li>
                <div class="file-table-list-container" title="@file.Name">
                    @file.Name
                </div>
            </li>
        }
    </ul>
}
</div>

<p hidden="@(!ShowLoader)">Loading...</p>

@code {
    [Parameter]
    public string Name { get; set; } = "NOT SET";

    [Parameter]
    public ContentTag Tag { get; set; } = ContentTag.Undefined;

    [Parameter]
    public long MaxFileSize { get; set; } = 1024000000;

    public List<IFileRecord> Files { get; private set; } = new List<IFileRecord>();

    private bool ShowContent { get; set; }
    private bool ShowLoader { get; set; } = true;

    protected override void OnInitialized()
    {
        IndexedDbCache.CacheHasChanged += OnCacheChanged;

        if(IndexedDbCache.Cache.ContainsKey(Tag)) {
            var cached = IndexedDbCache.Cache.GetValueOrDefault(Tag);

            Files = cached.OrderedRecords;
        }
        
        ShowContent = true;
        ShowLoader = false;
    }

    public async Task AddFileAsync(IBrowserFile file)
    {
        ShowContent = false;
        ShowLoader = true;

        StateHasChanged();

        var fileRecord = await ConvertBrowserFileToFileRecordAsync(file);

        await IndexedDbMgr.AddRecord(new StoreRecord<IFileRecord> {
            Storename = "files",
            Data = fileRecord
        });

        IndexedDbCache.Add(fileRecord);
    }

    private async Task<IFileRecord> ConvertBrowserFileToFileRecordAsync(IBrowserFile file) {
        using var fileStream = file.OpenReadStream(MaxFileSize);

        var buffer = new byte[fileStream.Length];

        await fileStream.ReadAsync(buffer);

       return new FileRecord {
            Name = file.Name,
            Tag = Tag,
            LastModified = DateTime.Now,
            Data = buffer
        };
    }

    private void OnCacheChanged(object sender, EventArgs e) {
        if(IndexedDbCache.Cache.ContainsKey(Tag)) {
            var cached = IndexedDbCache.Cache.GetValueOrDefault(Tag);

            Files = cached.OrderedRecords;
        }
        else {
            Files.Clear();
        }

        ShowLoader = false;
        ShowContent = true;

        StateHasChanged();
    }
}
